"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[151],{217:(t,e,a)=>{a.d(e,{db:()=>r});var i=a(1282);class n extends i.Ay{async addBudgetEntry(t){let e={...t,createdAt:new Date,updatedAt:new Date};return await this.budgetEntries.add(e)}async updateBudgetEntry(t,e){let a={...e,updatedAt:new Date};await this.budgetEntries.update(t,a)}async deleteBudgetEntry(t){await this.categories.where("budgetId").equals(t).delete(),await this.budgetEntries.delete(t)}async addAccount(t){let e={...t,createdAt:new Date,updatedAt:new Date};return await this.accounts.add(e)}async updateAccount(t,e){let a={...e,updatedAt:new Date};await this.accounts.update(t,a)}async deleteAccount(t){await this.accounts.delete(t)}async getAccount(t){return await this.accounts.get(t)}async getAllAccounts(){return await this.accounts.toArray()}async ensureDefaultAccount(){0===(await this.getAllAccounts()).length&&await this.addAccount({name:"Cash",description:"Default",type:"Cash",startingAmount:0})}async getDefaultAccount(){let t=await this.getDefaultAccountFromSettings();if(t)return t;let e=(await this.getAllAccounts()).find(t=>"Cash"===t.name);if(e)return e;let a=await this.addAccount({name:"Cash",description:"Default",type:"Cash",startingAmount:0});return await this.accounts.get(a)}async ensureDefaultBudgetAndCategory(){if(0===(await this.budgetEntries.toArray()).length){let t=await this.addBudgetEntry({name:"Groceries",amount:500});await this.addCategory({name:"Shopping",description:"General shopping expenses",budgetId:t})}}async getDefaultBudget(){let t=await this.getDefaultBudgetFromSettings();if(t)return t;let e=await this.budgetEntries.toArray(),a=e.find(t=>"Groceries"===t.name);if(a)return a;let i=e[0];if(i)return i;let n=await this.addBudgetEntry({name:"Default Budget",amount:0});return await this.budgetEntries.get(n)}async getDefaultSettings(){let t=parseInt(localStorage.getItem("defaultAccountId")||"0");return{defaultAccountId:t,defaultBudgetId:parseInt(localStorage.getItem("defaultBudgetId")||"0"),defaultCategoryId:parseInt(localStorage.getItem("defaultCategoryId")||"0")}}async setDefaultSettings(t){void 0!==t.defaultAccountId&&localStorage.setItem("defaultAccountId",t.defaultAccountId.toString()),void 0!==t.defaultBudgetId&&localStorage.setItem("defaultBudgetId",t.defaultBudgetId.toString()),void 0!==t.defaultCategoryId&&localStorage.setItem("defaultCategoryId",t.defaultCategoryId.toString())}async getDefaultAccountFromSettings(){let{defaultAccountId:t}=await this.getDefaultSettings();if(t>0)return await this.getAccount(t)}async getDefaultBudgetFromSettings(){let{defaultBudgetId:t}=await this.getDefaultSettings();if(t>0)return await this.budgetEntries.get(t)}async getDefaultCategoryFromSettings(){let{defaultCategoryId:t}=await this.getDefaultSettings();if(t>0)return await this.categories.get(t)}async getAccountCurrentBalance(t){let e=await this.accounts.get(t);if(!e)return 0;let a=(await this.transactions.where("accountId").equals(t).toArray()).reduce((t,e)=>"incoming"===e.direction?t+e.amount:t-e.amount,0);return e.startingAmount+a}async getAllAccountsWithBalances(){let t=await this.getAllAccounts();return await Promise.all(t.map(async t=>{let e=await this.getAccountCurrentBalance(t.id);return{...t,currentBalance:e}}))}async addCategory(t){let e={...t,createdAt:new Date,updatedAt:new Date};return await this.categories.add(e)}async updateCategory(t,e){let a={...e,updatedAt:new Date};await this.categories.update(t,a)}async deleteCategory(t){await this.transactions.where("categoryId").equals(t).modify({categoryId:0}),await this.categories.delete(t)}async getCategoriesByBudget(t){return await this.categories.where("budgetId").equals(t).toArray()}async addTransaction(t){let e={...t,createdAt:new Date,updatedAt:new Date};return await this.transactions.add(e)}async updateTransaction(t,e){let a={...e,updatedAt:new Date};await this.transactions.update(t,a)}async deleteTransaction(t){await this.receipts.where("transactionId").equals(t).modify({transactionId:void 0}),await this.transactions.delete(t)}async getTransactionsByCategory(t){return await this.transactions.where("categoryId").equals(t).toArray()}async getTransactionsByDateRange(t,e){return await this.transactions.where("date").between(t,e).toArray()}async addReceipt(t){if(await this.receipts.where(["fn","i","fp"]).equals([t.fn,t.i,t.fp]).first())throw Error("Receipt already exists with fiscal number: ".concat(t.fn,", receipt number: ").concat(t.i,", fiscal sign: ").concat(t.fp));let e={...t,createdAt:new Date,updatedAt:new Date},a=await this.receipts.add(e);try{let e=this.parseReceiptTimestamp(t.t),i=parseFloat(t.s)||0,n=await this.getDefaultCategory(),r=await this.getDefaultAccount(),d={date:e.date,time:e.time,categoryId:n.id||0,accountId:r.id||0,payerPayee:"Receipt ".concat(t.fn),amount:i,direction:"outgoing",receiptId:a,comment:"Auto-generated from receipt: ".concat(t.fn)},s=await this.addTransaction(d);await this.receipts.update(a,{transactionId:s})}catch(t){console.error("Failed to create transaction from receipt:",t)}return a}parseReceiptTimestamp(t){try{let e=parseInt(t.substring(0,4)),a=parseInt(t.substring(4,6))-1,i=parseInt(t.substring(6,8)),n=parseInt(t.substring(9,11))||0,r=parseInt(t.substring(11,13))||0,d=new Date(e,a,i),s="".concat(n.toString().padStart(2,"0"),":").concat(r.toString().padStart(2,"0"));return{date:d,time:s}}catch(t){return console.error("Error parsing receipt timestamp:",t),{date:new Date,time:"00:00"}}}async getDefaultCategory(){let t=await this.getDefaultCategoryFromSettings();if(t)return t;let e=await this.categories.where("name").equals("Shopping").first();if(e)return e;let a=(await this.categories.toArray())[0];if(a)return a;let i=(await this.budgetEntries.toArray())[0],n=1;n=i?i.id||1:await this.addBudgetEntry({name:"Default Budget",amount:0});let r=await this.addCategory({name:"General",description:"Default category for transactions",budgetId:n});return await this.categories.get(r)}async updateReceipt(t,e){let a={...e,updatedAt:new Date};await this.receipts.update(t,a)}async deleteReceipt(t){await this.transactions.where("receiptId").equals(t).modify({receiptId:void 0}),await this.receipts.delete(t)}async getReceiptByTransaction(t){return await this.receipts.where("transactionId").equals(t).first()}async getTransactionWithDetails(t){let e=await this.transactions.get(t);if(!e)return;let a=await this.categories.get(e.categoryId);return{transaction:e,category:a||{id:0,name:"Unknown",description:"",budgetId:0},receipt:await this.getReceiptByTransaction(t)}}async getBudgetWithCategories(t){let e=await this.budgetEntries.get(t);if(e)return{budget:e,categories:await this.getCategoriesByBudget(t)}}constructor(){super("FinanceDatabase"),this.version(1).stores({budgetEntries:"++id, name, amount, createdAt, updatedAt",accounts:"++id, name, description, type, startingAmount, createdAt, updatedAt",categories:"++id, name, description, budgetId, createdAt, updatedAt",transactions:"++id, date, categoryId, payerPayee, amount, direction, receiptId, createdAt, updatedAt",receipts:"++id, t, s, fn, i, fp, n, transactionId, createdAt, updatedAt"}),this.version(2).stores({budgetEntries:"++id, name, amount, createdAt, updatedAt",accounts:"++id, name, description, type, startingAmount, createdAt, updatedAt",categories:"++id, name, description, budgetId, createdAt, updatedAt",transactions:"++id, date, categoryId, payerPayee, amount, direction, receiptId, createdAt, updatedAt, [categoryId+date]",receipts:"++id, t, s, fn, i, fp, n, transactionId, createdAt, updatedAt"}),this.version(3).stores({budgetEntries:"++id, name, amount, createdAt, updatedAt",accounts:"++id, name, description, type, startingAmount, createdAt, updatedAt",categories:"++id, name, description, budgetId, createdAt, updatedAt",transactions:"++id, date, categoryId, payerPayee, amount, direction, receiptId, createdAt, updatedAt, [categoryId+date]",receipts:"++id, t, s, fn, i, fp, n, transactionId, createdAt, updatedAt, [fn+i+fp]"}),this.version(4).stores({budgetEntries:"++id, name, amount, createdAt, updatedAt",accounts:"++id, name, description, type, startingAmount, createdAt, updatedAt",categories:"++id, name, description, budgetId, createdAt, updatedAt",transactions:"++id, date, time, categoryId, payerPayee, amount, direction, receiptId, createdAt, updatedAt, [categoryId+date]",receipts:"++id, t, s, fn, i, fp, n, transactionId, createdAt, updatedAt, [fn+i+fp]"}),this.version(5).stores({budgetEntries:"++id, name, amount, createdAt, updatedAt",accounts:"++id, name, description, type, startingAmount, createdAt, updatedAt",categories:"++id, name, description, budgetId, createdAt, updatedAt",transactions:"++id, date, time, categoryId, payerPayee, amount, direction, receiptId, createdAt, updatedAt, [categoryId+date]",receipts:"++id, t, s, fn, i, fp, n, transactionId, createdAt, updatedAt, [fn+i+fp]"}).upgrade(async t=>{0===(await t.table("accounts").toArray()).length&&await t.table("accounts").add({name:"Cash",description:"Default",type:"Cash",startingAmount:0,createdAt:new Date,updatedAt:new Date})}),this.version(6).stores({budgetEntries:"++id, name, amount, createdAt, updatedAt",accounts:"++id, name, description, type, startingAmount, createdAt, updatedAt",categories:"++id, name, description, budgetId, createdAt, updatedAt",transactions:"++id, date, time, categoryId, accountId, payerPayee, amount, direction, receiptId, createdAt, updatedAt, [categoryId+date], [accountId+date]",receipts:"++id, t, s, fn, i, fp, n, transactionId, createdAt, updatedAt, [fn+i+fp]"}).upgrade(async t=>{let e=await t.table("accounts").where("name").equals("Cash").first();e&&await t.table("transactions").toCollection().modify({accountId:e.id})}),this.version(7).stores({budgetEntries:"++id, name, amount, createdAt, updatedAt",accounts:"++id, name, description, type, startingAmount, createdAt, updatedAt",categories:"++id, name, description, budgetId, createdAt, updatedAt",transactions:"++id, date, time, categoryId, accountId, payerPayee, amount, direction, receiptId, createdAt, updatedAt, [categoryId+date], [accountId+date]",receipts:"++id, t, s, fn, i, fp, n, transactionId, createdAt, updatedAt, [fn+i+fp]"}).upgrade(async t=>{if(0===(await t.table("budgetEntries").toArray()).length){let e=await t.table("budgetEntries").add({name:"Groceries",amount:500,createdAt:new Date,updatedAt:new Date});await t.table("categories").add({name:"Shopping",description:"General shopping expenses",budgetId:e,createdAt:new Date,updatedAt:new Date})}})}}let r=new n},239:t=>{t.exports=JSON.parse('{"name":"storage","version":"0.1.70","private":true,"scripts":{"dev":"next dev --experimental-https","build":"next build","start":"next start","lint":"next lint","copy":"rm -fr ../spir1donov.github.io/storage && cp -r out ../spir1donov.github.io/storage/","deploy":"cd ../spir1donov.github.io && git add . && git commit -m \\"deploy $(date -u +\'%Y%m%d%H%M%S\')\\" && git push","bump":"npm version patch --git-tag-version false","publish":"npm run bump && npm run build && npm run copy && npm run deploy"},"dependencies":{"@yudiel/react-qr-scanner":"^2.3.1","dexie":"^4.0.11","dexie-react-hooks":"^1.1.7","next":"15.3.4","react":"^19.0.0","react-dom":"^19.0.0"},"devDependencies":{"@eslint/eslintrc":"^3","@types/node":"^20","@types/react":"^19","@types/react-dom":"^19","autoprefixer":"^10.4.21","eslint":"^9","eslint-config-next":"15.3.4","tailwindcss":"^3.4.0","typescript":"^5"}}')},6979:(t,e,a)=>{a.d(e,{C3:()=>n,Ez:()=>i,Z:()=>r,hl:()=>c,uQ:()=>s,zi:()=>d});let i=5e3,n="FinanceTracker",r="min-h-screen bg-gray-50 dark:bg-gray-900 pb-20 md:pb-0 md:pt-16",d="max-w-6xl mx-auto p-6",s="text-3xl font-bold text-center mb-8 text-gray-900 dark:text-white",c="0.1.0";try{c=a(239).version||c}catch(t){console.warn("Could not load version from package.json, using default:",c)}}}]);